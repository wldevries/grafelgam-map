<div id="map" />

<div class="search">
    <AutoComplete
        placeholder="searchâ€¦"
        items={allLocations}
        bind:selectedItem={selectedLocation}        
        labelFieldName="name"
        onChange="{showLocation}"
        showClear="true" />
</div>

<div class="toolbar">
    <button class="btn-tool"
            bind:this={addRegionButton}
            on:click={selectRegionMode}>
        add region
    </button>
    <button class="btn-tool"
            bind:this={addLocationButton}
            on:click={selectLocationMode}>
        add location
    </button>
</div>

<script lang="ts">
    import { onMount } from "svelte";
    import AutoComplete from "simple-svelte-autocomplete";
    import * as L from "leaflet";
    import '@geoman-io/leaflet-geoman-free';  
    import '@geoman-io/leaflet-geoman-free/dist/leaflet-geoman.css';  

    let map: L.Map;
    let addRegionButton: HTMLButtonElement;
    let addLocationButton: HTMLButtonElement;
    let locationLayer: L.FeatureGroup<any>;

    let multipleSelected: boolean;
    let selectedLocation: Location;
    let allLocations: Location[] = [];

    // coordinates of region selected by the user
    let regionCoords: L.LatLng[] = [];
    let editRegion: L.Polygon;

    enum EditMode{
        None,
        Single,
        Region,
    }

    let mode = EditMode.None;

    function showLocation(location: Location) {
        if (location != undefined) {
            showLocations([location]);
        }
        else if (!multipleSelected && map != undefined) {
            map.removeLayer(locationLayer);
            locationLayer = undefined;
        }
    }

    function popupText(location: Location) : string {
        if (location.region == undefined) {
            return `<h3>${location.name}</h3><p>${location.country}</p>`;
        }
        return `<h3>${location.name}</h3><p>${location.country}  (${location.region})</p>`;
    }

    function selectLocationMode() {
        if (mode == EditMode.None){
            mode = EditMode.Single;
            addLocationButton.disabled = true;
            addRegionButton.disabled = true;
        }
    }
    
    function selectRegionMode() {
        if (mode == EditMode.None){
            mode = EditMode.Region;
            addLocationButton.disabled = true;
            addRegionButton.disabled = true;
        }
    }

    function resetEditMode(){
        mode = EditMode.None;
        addLocationButton.disabled = false;
        addRegionButton.disabled = false;
    }

    export function showLocations(locations: Location[]) {
        if (locationLayer != undefined) {
            map.removeLayer(locationLayer);
        }

        if (locations.length == 1) {
            selectedLocation = locations[0];
        }
        else if (locations.length > 1) {
            multipleSelected = true;
            selectedLocation = undefined;
        }
        else {
            selectedLocation = undefined;
        }

        if (locations.length > 0) {
            locationLayer = new L.FeatureGroup().addTo(map);

            locations.forEach(l => {
                const m = L.marker(l.loc)
                    .addTo(locationLayer)
                    .bindTooltip(popupText(l));
                
                    if (locations.length == 1) {
                        const p = new L.Popup({ autoClose: false })
                            .setContent(popupText(l))
                            .setLatLng(l.loc);
                        m.bindPopup(p).openPopup();
                }
            });
            
            map.fitBounds(L.latLngBounds(locations.map(l => l.loc)));
        }
    }

    onMount(async () => {
        var moptions: L.MapOptions = {
            zoomSnap: 0.5,
            zoomDelta: 0.5,
        };
        map = L.map("map", moptions);

        var options: L.TileLayerOptions = {
            minZoom: 1,
            maxZoom: 5,
            noWrap: true,
        };
        L.tileLayer("tiles/{z}/{x}/{y}.png", options).addTo(map);

        map.setView([0, 0], 3);

        // Debug out for location
        map.on("click", function (ev: L.LeafletMouseEvent) {
            if (mode == EditMode.None) {
                console.log(ev.latlng.lat + ", " + ev.latlng.lng);
            }
            else if (mode == EditMode.Single) {
                alert(ev.latlng.lat + ", " + ev.latlng.lng);
                resetEditMode();
            }
            else if (mode == EditMode.Region) {                
                regionCoords.push(ev.latlng);
                if (editRegion != null) {
                    map.removeLayer(editRegion);
                }
                editRegion = L.polygon(regionCoords);
                editRegion.addTo(map);
            }
        });

        await loadLocations();

        map.pm.addControls({  
            position: 'topleft',
            drawCircle: false,
            drawText: false,
            rotateMode: false,
        });
    });

    async function loadLocations() {
        allLocations = await fetch("locations.json").then((response) =>
            response.json()
        );

        allLocations.sort((a, b) => a.name.localeCompare(b.name));
    }
</script>

<style>
    #map {
        position: fixed;
        background: #222;
        z-index: 0;
        top: 65px;
        left: 0px;
        right: 0px;
        bottom: 0px;
    }

    /* More styling is on autocomplete class in global styles */
    .search {
        width: 250px;
        position: fixed;
        top: 76px;
        left: 80px;
    }

    .toolbar {
        position: fixed;
        top: 200px;
        left: 80px;
    }
    .btn-tool {
        border-radius: 4px;
        /* width: 100px; */
    }
</style>
